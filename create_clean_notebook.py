#!/usr/bin/env python3
"""Clean notebook creator"""

import json

cells = [
    # Cell 1: Imports
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# ============================================================================\n",
            "# Cell 1: Imports\n",
            "# ============================================================================\n",
            "import numpy as np\n",
            "import matplotlib.pyplot as plt\n",
            "import cv2\n",
            "from scipy.ndimage import uniform_filter, gaussian_filter\n",
            "from skimage.segmentation import slic\n",
            "from skimage.measure import regionprops"
        ]
    },
    # Cell 2: Basic smoothing functions
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# ============================================================================\n",
            "# Cell 2: 기본 Smoothing 함수 정의\n",
            "# ============================================================================\n",
            "\n",
            "def fill_holes_completely(depth, invalid_value=0.0):\n",
            "    \"\"\"구멍을 완전히 채우는 함수 (inpainting + morphological closing)\"\"\"\n",
            "    mask = (depth > invalid_value) & ~np.isnan(depth)\n",
            "    depth_filled = depth.copy().astype(np.float32)\n",
            "    \n",
            "    if mask.all():\n",
            "        return depth_filled\n",
            "    \n",
            "    mask_uint8 = (~mask).astype(np.uint8) * 255\n",
            "    depth_filled = cv2.inpaint(depth_filled, mask_uint8, 10, cv2.INPAINT_TELEA)\n",
            "    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (15, 15))\n",
            "    depth_filled = cv2.morphologyEx(depth_filled, cv2.MORPH_CLOSE, kernel)\n",
            "    \n",
            "    return depth_filled\n",
            "\n",
            "\n",
            "def smooth_heavy_downup(depth, scale=0.1, invalid_value=0.0):\n",
            "    \"\"\"매우 강한 다운샘플링으로 디테일 제거 + 구멍 채우기\"\"\"\n",
            "    H, W = depth.shape\n",
            "    depth_filled = fill_holes_completely(depth, invalid_value)\n",
            "    \n",
            "    h_small = max(1, int(H * scale))\n",
            "    w_small = max(1, int(W * scale))\n",
            "    depth_small = cv2.resize(depth_filled, (w_small, h_small), interpolation=cv2.INTER_AREA)\n",
            "    depth_coarse = cv2.resize(depth_small, (W, H), interpolation=cv2.INTER_LINEAR)\n",
            "    \n",
            "    return depth_coarse\n",
            "\n",
            "\n",
            "def smooth_superpixel(depth, n_segments=200, compactness=10, invalid_value=0.0):\n",
            "    \"\"\"Superpixel 기반 단순화 - 각 영역을 대표 depth로 표현\"\"\"\n",
            "    depth_filled = fill_holes_completely(depth, invalid_value)\n",
            "    \n",
            "    depth_norm = (depth_filled - depth_filled.min()) / (depth_filled.max() - depth_filled.min() + 1e-8)\n",
            "    depth_3ch = np.stack([depth_norm] * 3, axis=-1)\n",
            "    \n",
            "    segments = slic(depth_3ch, n_segments=n_segments, compactness=compactness, \n",
            "                    start_label=0, channel_axis=-1)\n",
            "    \n",
            "    depth_simplified = np.zeros_like(depth_filled)\n",
            "    for region_id in np.unique(segments):\n",
            "        mask = segments == region_id\n",
            "        depth_simplified[mask] = depth_filled[mask].mean()\n",
            "    \n",
            "    return depth_simplified\n",
            "\n",
            "\n",
            "def smooth_quantized(depth, n_levels=8, invalid_value=0.0):\n",
            "    \"\"\"Depth를 N개의 대표 값으로 양자화\"\"\"\n",
            "    depth_filled = fill_holes_completely(depth, invalid_value)\n",
            "    \n",
            "    valid_mask = depth_filled > invalid_value\n",
            "    if not valid_mask.any():\n",
            "        return depth_filled\n",
            "    \n",
            "    min_d, max_d = depth_filled[valid_mask].min(), depth_filled[valid_mask].max()\n",
            "    bins = np.linspace(min_d, max_d, n_levels + 1)\n",
            "    bin_centers = (bins[:-1] + bins[1:]) / 2\n",
            "    \n",
            "    indices = np.digitize(depth_filled, bins) - 1\n",
            "    indices = np.clip(indices, 0, n_levels - 1)\n",
            "    depth_quantized = bin_centers[indices]\n",
            "    depth_quantized = cv2.GaussianBlur(depth_quantized.astype(np.float32), (5, 5), 1.5)\n",
            "    \n",
            "    return depth_quantized\n",
            "\n",
            "\n",
            "def smooth_iterative_inpaint_blur(depth, iterations=3, blur_sigma=5.0, invalid_value=0.0):\n",
            "    \"\"\"반복적 inpainting + 강한 블러로 구멍 채우고 단순화\"\"\"\n",
            "    depth_result = depth.copy().astype(np.float32)\n",
            "    \n",
            "    for i in range(iterations):\n",
            "        mask = (depth_result <= invalid_value) | np.isnan(depth_result)\n",
            "        if mask.any():\n",
            "            mask_uint8 = mask.astype(np.uint8) * 255\n",
            "            depth_result = cv2.inpaint(depth_result, mask_uint8, 5, cv2.INPAINT_TELEA)\n",
            "        \n",
            "        kernel_size = int(blur_sigma * 4) | 1\n",
            "        depth_result = cv2.GaussianBlur(depth_result, (kernel_size, kernel_size), blur_sigma)\n",
            "    \n",
            "    return depth_result\n",
            "\n",
            "\n",
            "def smooth_planar_fit(depth, grid_size=32, invalid_value=0.0):\n",
            "    \"\"\"그리드 영역별 평면 fitting으로 단순화\"\"\"\n",
            "    H, W = depth.shape\n",
            "    depth_filled = fill_holes_completely(depth, invalid_value)\n",
            "    depth_planar = np.zeros_like(depth_filled)\n",
            "    \n",
            "    for i in range(0, H, grid_size):\n",
            "        for j in range(0, W, grid_size):\n",
            "            i_end = min(i + grid_size, H)\n",
            "            j_end = min(j + grid_size, W)\n",
            "            block = depth_filled[i:i_end, j:j_end]\n",
            "            depth_planar[i:i_end, j:j_end] = block.mean()\n",
            "    \n",
            "    depth_planar = cv2.GaussianBlur(depth_planar.astype(np.float32), (15, 15), 3.0)\n",
            "    return depth_planar\n",
            "\n",
            "\n",
            "print('기본 smoothing 함수 정의 완료!')"
        ]
    },
    # Cell 3: Superpixel variations
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# ============================================================================\n",
            "# Cell 3: Superpixel 변형 함수들\n",
            "# ============================================================================\n",
            "\n",
            "def smooth_superpixel_extreme(depth, n_segments=30, compactness=30, blur_sigma=3.0, invalid_value=0.0):\n",
            "    \"\"\"극단적으로 단순화된 Superpixel - 매우 적은 세그먼트 + 후처리 블러\"\"\"\n",
            "    depth_filled = fill_holes_completely(depth, invalid_value)\n",
            "    \n",
            "    depth_norm = (depth_filled - depth_filled.min()) / (depth_filled.max() - depth_filled.min() + 1e-8)\n",
            "    depth_3ch = np.stack([depth_norm] * 3, axis=-1)\n",
            "    \n",
            "    segments = slic(depth_3ch, n_segments=n_segments, compactness=compactness, \n",
            "                    start_label=0, channel_axis=-1)\n",
            "    \n",
            "    depth_simplified = np.zeros_like(depth_filled)\n",
            "    for region_id in np.unique(segments):\n",
            "        mask = segments == region_id\n",
            "        depth_simplified[mask] = depth_filled[mask].mean()\n",
            "    \n",
            "    if blur_sigma > 0:\n",
            "        kernel_size = int(blur_sigma * 4) | 1\n",
            "        depth_simplified = cv2.GaussianBlur(depth_simplified.astype(np.float32), \n",
            "                                            (kernel_size, kernel_size), blur_sigma)\n",
            "    \n",
            "    return depth_simplified\n",
            "\n",
            "\n",
            "def smooth_superpixel_hierarchical(depth, levels=[200, 50, 15], invalid_value=0.0):\n",
            "    \"\"\"계층적 Superpixel - 여러 단계로 점진적 단순화\"\"\"\n",
            "    depth_filled = fill_holes_completely(depth, invalid_value)\n",
            "    depth_result = depth_filled.copy()\n",
            "    \n",
            "    for n_seg in levels:\n",
            "        depth_norm = (depth_result - depth_result.min()) / (depth_result.max() - depth_result.min() + 1e-8)\n",
            "        depth_3ch = np.stack([depth_norm] * 3, axis=-1)\n",
            "        \n",
            "        segments = slic(depth_3ch, n_segments=n_seg, compactness=20, \n",
            "                        start_label=0, channel_axis=-1)\n",
            "        \n",
            "        for region_id in np.unique(segments):\n",
            "            mask = segments == region_id\n",
            "            depth_result[mask] = depth_result[mask].mean()\n",
            "    \n",
            "    return depth_result\n",
            "\n",
            "\n",
            "def smooth_superpixel_quantized(depth, n_segments=100, n_depth_levels=5, invalid_value=0.0):\n",
            "    \"\"\"Superpixel + Depth 양자화 결합\"\"\"\n",
            "    depth_filled = fill_holes_completely(depth, invalid_value)\n",
            "    \n",
            "    depth_norm = (depth_filled - depth_filled.min()) / (depth_filled.max() - depth_filled.min() + 1e-8)\n",
            "    depth_3ch = np.stack([depth_norm] * 3, axis=-1)\n",
            "    segments = slic(depth_3ch, n_segments=n_segments, compactness=15, \n",
            "                    start_label=0, channel_axis=-1)\n",
            "    \n",
            "    depth_sp = np.zeros_like(depth_filled)\n",
            "    for region_id in np.unique(segments):\n",
            "        mask = segments == region_id\n",
            "        depth_sp[mask] = depth_filled[mask].mean()\n",
            "    \n",
            "    min_d, max_d = depth_sp.min(), depth_sp.max()\n",
            "    bins = np.linspace(min_d, max_d, n_depth_levels + 1)\n",
            "    bin_centers = (bins[:-1] + bins[1:]) / 2\n",
            "    indices = np.digitize(depth_sp, bins) - 1\n",
            "    indices = np.clip(indices, 0, n_depth_levels - 1)\n",
            "    depth_quantized = bin_centers[indices]\n",
            "    \n",
            "    return depth_quantized\n",
            "\n",
            "\n",
            "print('Superpixel 변형 함수 정의 완료!')"
        ]
    },
    # Cell 4: Binning functions
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# ============================================================================\n",
            "# Cell 4: Binning 함수들 (Classification용)\n",
            "# ============================================================================\n",
            "\n",
            "def depth_to_bins(depth, n_bins=128, depth_min=None, depth_max=None, invalid_value=0.0):\n",
            "    \"\"\"Depth를 N개의 bin (class label)로 변환 - Linear\"\"\"\n",
            "    depth_filled = fill_holes_completely(depth, invalid_value)\n",
            "    \n",
            "    if depth_min is None:\n",
            "        depth_min = depth_filled[depth_filled > invalid_value].min()\n",
            "    if depth_max is None:\n",
            "        depth_max = depth_filled.max()\n",
            "    \n",
            "    bins = np.linspace(depth_min, depth_max, n_bins + 1)\n",
            "    bin_centers = (bins[:-1] + bins[1:]) / 2\n",
            "    \n",
            "    bin_indices = np.digitize(depth_filled, bins) - 1\n",
            "    bin_indices = np.clip(bin_indices, 0, n_bins - 1)\n",
            "    \n",
            "    return bin_indices, bin_centers, bins\n",
            "\n",
            "\n",
            "def depth_to_bins_log(depth, n_bins=128, invalid_value=0.0):\n",
            "    \"\"\"Log-scale binning - 가까운 거리에 더 많은 bin 할당\"\"\"\n",
            "    depth_filled = fill_holes_completely(depth, invalid_value)\n",
            "    \n",
            "    depth_min = depth_filled[depth_filled > invalid_value].min()\n",
            "    depth_max = depth_filled.max()\n",
            "    \n",
            "    bins = np.logspace(np.log10(depth_min), np.log10(depth_max), n_bins + 1)\n",
            "    bin_centers = (bins[:-1] + bins[1:]) / 2\n",
            "    \n",
            "    bin_indices = np.digitize(depth_filled, bins) - 1\n",
            "    bin_indices = np.clip(bin_indices, 0, n_bins - 1)\n",
            "    \n",
            "    return bin_indices, bin_centers, bins\n",
            "\n",
            "\n",
            "def depth_to_bins_sid(depth, n_bins=128, alpha=0.5, invalid_value=0.0):\n",
            "    \"\"\"SID (Spacing-Increasing Discretization) - DORN paper 방식\"\"\"\n",
            "    depth_filled = fill_holes_completely(depth, invalid_value)\n",
            "    \n",
            "    depth_min = depth_filled[depth_filled > invalid_value].min()\n",
            "    depth_max = depth_filled.max()\n",
            "    \n",
            "    t = np.linspace(0, 1, n_bins + 1)\n",
            "    bins = depth_min * (depth_max / depth_min) ** (t ** alpha)\n",
            "    bin_centers = (bins[:-1] + bins[1:]) / 2\n",
            "    \n",
            "    bin_indices = np.digitize(depth_filled, bins) - 1\n",
            "    bin_indices = np.clip(bin_indices, 0, n_bins - 1)\n",
            "    \n",
            "    return bin_indices, bin_centers, bins\n",
            "\n",
            "\n",
            "def bins_to_depth(bin_indices, bin_centers):\n",
            "    \"\"\"Bin indices를 다시 depth 값으로 변환\"\"\"\n",
            "    return bin_centers[bin_indices]\n",
            "\n",
            "\n",
            "def smooth_binned(depth, n_bins=128, pre_smooth=None, post_blur=0, invalid_value=0.0):\n",
            "    \"\"\"Bin 기반 단순화 + 선택적 전/후처리\"\"\"\n",
            "    depth_processed = depth.copy().astype(np.float32)\n",
            "    \n",
            "    if pre_smooth == 'downup':\n",
            "        depth_processed = smooth_heavy_downup(depth_processed, scale=0.1)\n",
            "    elif pre_smooth == 'superpixel':\n",
            "        depth_processed = smooth_superpixel(depth_processed, n_segments=100)\n",
            "    \n",
            "    bin_indices, bin_centers, _ = depth_to_bins(depth_processed, n_bins=n_bins)\n",
            "    depth_binned = bins_to_depth(bin_indices, bin_centers)\n",
            "    \n",
            "    if post_blur > 0:\n",
            "        kernel_size = int(post_blur * 4) | 1\n",
            "        depth_binned = cv2.GaussianBlur(depth_binned.astype(np.float32), \n",
            "                                        (kernel_size, kernel_size), post_blur)\n",
            "    \n",
            "    return depth_binned, bin_indices\n",
            "\n",
            "\n",
            "print('Binning 함수 정의 완료!')"
        ]
    },
    # Cell 5: Data loading
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# ============================================================================\n",
            "# Cell 5: 데이터 로드\n",
            "# ============================================================================\n",
            "\n",
            "base_path = '/root/dev/data/dataset/Batvision/BatvisionV2/2ndFloorLuxembourg'\n",
            "file_idx = 0\n",
            "\n",
            "# 원본 depth 로드\n",
            "depth_original = np.load(f'{base_path}/depth/depth_{file_idx}.npy').astype(np.float32)\n",
            "\n",
            "# 컬러 범위 설정\n",
            "valid_mask = depth_original > 0\n",
            "vmin, vmax = depth_original[valid_mask].min(), depth_original[valid_mask].max()\n",
            "\n",
            "print(f'Depth loaded: {depth_original.shape}')\n",
            "print(f'Valid range: {vmin:.1f} ~ {vmax:.1f}')"
        ]
    },
    # Cell 6: Main visualization
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# ============================================================================\n",
            "# Cell 6: 전체 30개 방법 종합 시각화 (10 x 3 Grid)\n",
            "# ============================================================================\n",
            "\n",
            "print('30개 방법 계산 중...')\n",
            "\n",
            "all_30_methods = [\n",
            "    # Row 1: Original + Down-Up\n",
            "    ('1. Original', depth_original),\n",
            "    ('2. Down-Up (0.15)', smooth_heavy_downup(depth_original, scale=0.15)),\n",
            "    ('3. Down-Up (0.05)', smooth_heavy_downup(depth_original, scale=0.05)),\n",
            "    \n",
            "    # Row 2: Superpixel 기본\n",
            "    ('4. Superpixel (n=300)', smooth_superpixel(depth_original, n_segments=300)),\n",
            "    ('5. Superpixel (n=100)', smooth_superpixel(depth_original, n_segments=100)),\n",
            "    ('6. Superpixel (n=40)', smooth_superpixel(depth_original, n_segments=40)),\n",
            "    \n",
            "    # Row 3: Superpixel Extreme\n",
            "    ('7. SP Extreme (n=50)', smooth_superpixel_extreme(depth_original, n_segments=50, blur_sigma=2.0)),\n",
            "    ('8. SP Extreme (n=25)', smooth_superpixel_extreme(depth_original, n_segments=25, blur_sigma=3.0)),\n",
            "    ('9. SP Extreme (n=12)', smooth_superpixel_extreme(depth_original, n_segments=12, blur_sigma=4.0)),\n",
            "    \n",
            "    # Row 4: Superpixel Hierarchical\n",
            "    ('10. SP Hier [200-80]', smooth_superpixel_hierarchical(depth_original, levels=[200, 80])),\n",
            "    ('11. SP Hier [150-50-20]', smooth_superpixel_hierarchical(depth_original, levels=[150, 50, 20])),\n",
            "    ('12. SP Hier [80-25-8]', smooth_superpixel_hierarchical(depth_original, levels=[80, 25, 8])),\n",
            "    \n",
            "    # Row 5: Quantization\n",
            "    ('13. Quantized (32 lv)', smooth_quantized(depth_original, n_levels=32)),\n",
            "    ('14. Quantized (12 lv)', smooth_quantized(depth_original, n_levels=12)),\n",
            "    ('15. Quantized (5 lv)', smooth_quantized(depth_original, n_levels=5)),\n",
            "    \n",
            "    # Row 6: Planar Grid\n",
            "    ('16. Grid (24x24)', smooth_planar_fit(depth_original, grid_size=24)),\n",
            "    ('17. Grid (48x48)', smooth_planar_fit(depth_original, grid_size=48)),\n",
            "    ('18. Grid (96x96)', smooth_planar_fit(depth_original, grid_size=96)),\n",
            "    \n",
            "    # Row 7: Iterative Blur\n",
            "    ('19. Iter Blur (s=3, i=2)', smooth_iterative_inpaint_blur(depth_original, iterations=2, blur_sigma=3.0)),\n",
            "    ('20. Iter Blur (s=6, i=3)', smooth_iterative_inpaint_blur(depth_original, iterations=3, blur_sigma=6.0)),\n",
            "    ('21. Iter Blur (s=10, i=4)', smooth_iterative_inpaint_blur(depth_original, iterations=4, blur_sigma=10.0)),\n",
            "    \n",
            "    # Row 8: Binning (Linear)\n",
            "    ('22. 128 Bins (Linear)', bins_to_depth(*depth_to_bins(depth_original, n_bins=128)[:2])),\n",
            "    ('23. 64 Bins (Linear)', bins_to_depth(*depth_to_bins(depth_original, n_bins=64)[:2])),\n",
            "    ('24. 32 Bins (Linear)', bins_to_depth(*depth_to_bins(depth_original, n_bins=32)[:2])),\n",
            "    \n",
            "    # Row 9: Binning (Log/SID)\n",
            "    ('25. 128 Bins (Log)', bins_to_depth(*depth_to_bins_log(depth_original, n_bins=128)[:2])),\n",
            "    ('26. 128 Bins (SID a=0.6)', bins_to_depth(*depth_to_bins_sid(depth_original, n_bins=128, alpha=0.6)[:2])),\n",
            "    ('27. 64 Bins (SID a=0.7)', bins_to_depth(*depth_to_bins_sid(depth_original, n_bins=64, alpha=0.7)[:2])),\n",
            "    \n",
            "    # Row 10: Combined\n",
            "    ('28. SP+Quant (n=80, 8lv)', smooth_superpixel_quantized(depth_original, n_segments=80, n_depth_levels=8)),\n",
            "    ('29. Down-128Bins-Blur', smooth_binned(depth_original, n_bins=128, pre_smooth='downup', post_blur=2.0)[0]),\n",
            "    ('30. SP-64Bins', smooth_binned(smooth_superpixel(depth_original, n_segments=150), n_bins=64)[0]),\n",
            "]\n",
            "\n",
            "print(f'{len(all_30_methods)}개 방법 준비 완료!')\n",
            "\n",
            "# 10 x 3 그리드 시각화\n",
            "fig, axes = plt.subplots(10, 3, figsize=(18, 48))\n",
            "axes = axes.flatten()\n",
            "\n",
            "for idx, (ax, (name, data)) in enumerate(zip(axes, all_30_methods)):\n",
            "    im = ax.imshow(data, cmap='viridis', vmin=vmin, vmax=vmax)\n",
            "    ax.set_title(name, fontsize=10, fontweight='bold' if idx == 0 else 'normal')\n",
            "    ax.axis('off')\n",
            "\n",
            "cbar_ax = fig.add_axes([0.92, 0.15, 0.02, 0.7])\n",
            "fig.colorbar(im, cax=cbar_ax, label='Depth Value')\n",
            "\n",
            "plt.suptitle('30 Depth Simplification Methods Comparison', fontsize=16, y=0.995)\n",
            "plt.tight_layout(rect=[0, 0, 0.9, 0.99])\n",
            "plt.savefig('all_30_methods.png', dpi=150, bbox_inches='tight')\n",
            "plt.show()\n",
            "\n",
            "print('\\nall_30_methods.png 저장 완료!')"
        ]
    },
    # Cell 7: Summary
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# ============================================================================\n",
            "# Cell 7: 30개 방법 요약표\n",
            "# ============================================================================\n",
            "\n",
            "summary = '''\n",
            "============================================================================\n",
            "                   30개 Depth 단순화 방법 요약\n",
            "============================================================================\n",
            "\n",
            "Row 1: Down-Up (다운샘플링)\n",
            "  - Original -> scale=0.15 -> scale=0.05\n",
            "  - 공간적 해상도 감소, 저주파 보존\n",
            "\n",
            "Row 2: Superpixel (영역 기반)\n",
            "  - n=300 -> n=100 -> n=40\n",
            "  - 유사 depth 영역으로 분할, 각 영역 평균 depth\n",
            "\n",
            "Row 3: SP Extreme (강한 영역화 + Blur)\n",
            "  - n=50 -> n=25 -> n=12\n",
            "  - 적은 영역 + 후처리 블러로 경계 부드럽게\n",
            "\n",
            "Row 4: SP Hierarchical (계층적)\n",
            "  - [200-80] -> [150-50-20] -> [80-25-8]\n",
            "  - 다단계 점진적 단순화\n",
            "\n",
            "Row 5: Quantization (depth 이산화)\n",
            "  - 32 levels -> 12 levels -> 5 levels\n",
            "  - depth 값을 N개 대표값으로 양자화\n",
            "\n",
            "Row 6: Planar Grid (블록 기반)\n",
            "  - 24x24 -> 48x48 -> 96x96\n",
            "  - 고정 그리드로 분할, 블록당 평균값\n",
            "\n",
            "Row 7: Iterative Blur (반복 블러)\n",
            "  - (s=3,i=2) -> (s=6,i=3) -> (s=10,i=4)\n",
            "  - 구멍 채우기 + 강한 가우시안 블러\n",
            "\n",
            "Row 8: Binning Linear (균등 분할)\n",
            "  - 128 bins -> 64 bins -> 32 bins\n",
            "  - 균등한 bin 폭, Classification용\n",
            "\n",
            "Row 9: Binning Log/SID (비균등 분할)\n",
            "  - 128 Log -> 128 SID -> 64 SID\n",
            "  - 가까운 거리에 더 촘촘한 bin\n",
            "\n",
            "Row 10: Combined (조합)\n",
            "  - SP+Quant -> Down-Bins-Blur -> SP-Bins\n",
            "  - 여러 방법 결합\n",
            "\n",
            "============================================================================\n",
            "용도별 추천:\n",
            "  - Coarse Classification (128 bins): #22, #25, #26, #29\n",
            "  - 영역 기반 대표 depth: #5, #8, #11, #28\n",
            "  - 연속적/부드러운 결과: #3, #20, #21\n",
            "  - 강한 단순화 (뭉개기): #9, #12, #15, #18\n",
            "============================================================================\n",
            "'''\n",
            "\n",
            "print(summary)\n",
            "\n",
            "# 각 방법별 고유 depth 값 수 계산\n",
            "print('\\n각 방법별 고유 depth 값 수:')\n",
            "print('-' * 50)\n",
            "for i, (name, data) in enumerate(all_30_methods):\n",
            "    unique_count = len(np.unique(data.round(1)))\n",
            "    print(f'  {name:30s}: {unique_count:6d} unique values')"
        ]
    }
]

notebook = {
    "cells": cells,
    "metadata": {
        "kernelspec": {
            "display_name": "Python 3",
            "language": "python",
            "name": "python3"
        },
        "language_info": {
            "name": "python",
            "version": "3.11.0"
        }
    },
    "nbformat": 4,
    "nbformat_minor": 4
}

with open('EDA_clean.ipynb', 'w', encoding='utf-8') as f:
    json.dump(notebook, f, indent=1, ensure_ascii=False)

print("EDA_clean.ipynb 생성 완료!")

